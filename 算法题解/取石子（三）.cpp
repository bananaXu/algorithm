#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <stack>
#include <cmath>
#include <vector> 
#include <queue>
#include <set>
#include <ctype.h>
#include <map>
#include <cfloat>
using namespace std;

bool ok(int a[])
{
	for (int i = 1; i <= 100; i ++)
		if (a[i]&1)
			return true;
	return false;
}

int main()
{
	while (1)
	{
		int n;
		scanf("%d", &n);
		if (n == 0)
			break;
		int a[105];
		memset(a, 0, sizeof(a)); 
		for (int i = 1; i <= n; i ++)
		{
			int x;
			scanf("%d", &x);
			a[x] ++;
		}
		if (ok(a))
			printf("Win\n");
		else
			printf("Lose\n");
	} 
	return 0;
}
//思想：1、如果石子堆成对出现，那么必输，另一个人可以跟他做相同动作
///2、如果有不成对的，那么用最大的不成对的那堆石子去填补之前的，
// 由于每个数量的石子堆一定只有一个不成对，那么最大的石子堆一定可以将前面的全部补成对，那么必胜 
/*
取石子（三）
时间限制：1000 ms  |  内存限制：10000 KB
难度：6
描述
小王喜欢与同事玩一些小游戏，今天他们选择了玩取石子。

游戏规则如下：共有N堆石子，已知每堆中石子的数量，两个人轮流取子，每次只能选择N堆石子中的一堆，取一定数量的石子（最少取一个），取过子之后，还可以将该堆石子中剩下的任意多个石子中随意选取几个放到其它的任意一堆或几堆上。等哪个人无法取子时就表示此人输掉了游戏。注意，一堆石子没有子之后，就不能再往此处放石子了。

假设每次都是小王先取石子，并且游戏双方都绝对聪明，现在给你石子的堆数、每堆石子的数量，请判断出小王能否获胜。

例如：如果最开始有4堆石子，石子个数分别为3 1 4 2，而小王想决定要先拿走第三堆石子中的两个石子（石子堆状态变为3 1 2 2），然后他可以使石子堆达到的状态有以下几种：

3 1 2 2（不再移动石子）

4 1 1 2（移动到第一堆一个）

3 2 1 2（移动到第二堆一个）

3 1 1 3（移动到第四堆一个）

5 1 0 2（全部移动到第一堆）

3 3 0 2（全部移动到第二堆）

3 1 0 4（全部移动到最后）

输入
可能有多组测试数据(测试数据组数不超过1000)
每组测试数据的第一行是一个整数，表示N(1<=N<=10)
第二行是N个整数分别表示该堆石子中石子的数量。（每堆石子数目不超过100）
当输入的N为0时，表示输入结束
输出
对于每组测试数据，输出Win表示小王可以获胜，输出Lose表示小王必然会败。
样例输入
3
2 1 3
2
1 1
0
样例输出
Win
Lose
*/
